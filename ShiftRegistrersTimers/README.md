# Система управления двузначным секундомером на Arduino и 74HC595

## Описание проекта

Данный проект представляет собой реализацию двузначного секундомера (от 00 до 59) на платформе Arduino Uno. Управление двумя семисегментными индикаторами осуществляется через каскадное соединение двух сдвиговых регистров 74HC595.

Пользователь может взаимодействовать с секундомером через последовательный порт, отправляя начальное значение или временно переопределяя отображаемое число.

## Логика работы

### Аппаратная часть

1.  **Сдвиговые регистры (74HC595):** Два регистра соединены каскадно. Выход `Q7'` первого регистра подключен к входу `DS` второго. Это позволяет управлять ими как единым 16-битным регистром.
2.  **Управляющие пины:**
    *   `DATA` (DS, пин 14): На этот пин последовательно подаются биты данных.
    *   `CLOCK` (SH_CP, пин 11): Каждый импульс `LOW`->`HIGH`->`LOW` на этом пине "заталкивает" бит с `DATA` в регистр, сдвигая предыдущие.
    *   `LATCH` (ST_CP, пин 12): Импульс `LOW`->`HIGH` на этом пине копирует данные из внутреннего сдвигового регистра на выходы (`Q0-Q7`), обновляя состояние индикаторов.

### Программная часть

#### 1. Инициализация (`setup()`)

*   Настраиваются управляющие пины на выход.
*   Инициализируется `Serial` для связи с ПК.
*   Настраивается `Timer1` для генерации прерывания `TIMER1_COMPA_vect` с частотой 1 Гц (каждую секунду).

#### 2. Главный цикл (`loop()`)

Основная задача `loop()` — неблокирующая обработка пользовательского ввода из `Serial`.
*   Цикл постоянно проверяет наличие данных в порту.
*   Символы накапливаются в статическом буфере до получения символа новой строки (`\n`).
*   Когда ввод завершен, буфер преобразуется в число.
*   Полученное значение атомарно (с отключением прерываний) записывается в `volatile` переменную `user_value`, которая будет прочитана в `ISR`.

#### 3. Обработчик прерывания (`ISR(TIMER1_COMPA_vect)`)

Этот код выполняется автоматически каждую секунду.
1.  **Чтение пользовательского ввода:** `ISR` проверяет, есть ли новое значение в переменной `user_value`.
2.  **Обновление счетчика:** Внутренний `seconds_counter` инкрементируется каждую секунду (после инициализации).
3.  **Логика отображения:**
    *   Если пользователь отправил новое значение, именно оно будет отображено на индикаторах в текущую секунду.
    *   Если нового значения нет, отображается текущее значение `seconds_counter`.
    *   Таким образом реализуется логика временного переопределения, как показано на диаграмме:

    ```
    Внутренний счетчик: 45 -> 46 -> 47 -> 48 -> ...
    Ввод пользователя:           | (отправлено '10')
    Отображение:       45 -> 46 -> 10 -> 48 -> ...
    ```

4.  **Отправка данных в регистры:**
    *   Сигнал `LATCH` устанавливается в `LOW`.
    *   С помощью кастомной функции `shift_byte()` в регистры последовательно отправляются два байта: сначала для разряда десятков, затем для единиц.
    *   Сигнал `LATCH` устанавливается в `HIGH`, мгновенно обновляя оба индикатора.