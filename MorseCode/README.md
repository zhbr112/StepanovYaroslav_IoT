# Документация: Полудуплексная система связи на основе азбуки Морзе

## Оглавление
1. [Обзор системы](#обзор-системы)
2. [Временные диаграммы](#временные-диаграммы)
3. [Конечные автоматы](#конечные-автоматы)
4. [Режимы работы](#режимы-работы)
5. [Проектные решения](#проектные-решения)
6. [Ограничения системы](#ограничения-системы)

---

## Обзор системы

### Назначение
Система реализует полудуплексную связь между двумя микроконтроллерами Arduino с использованием азбуки Морзе. Каждый МК симметрично может выступать как передатчиком, так и приёмником, но не одновременно.

### Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                    МИКРОКОНТРОЛЛЕР                          │
├─────────────────────────────────────────────────────────────┤
│  Входы:                    │  Выходы:                       │
│  • Serial (USB)            │  • PIN_TX (GPIO 3) → МК2       │
│  • PIN_RX (GPIO 2) ← МК2   │  • 74HC595 (дисплей)           │
│  • PIN_BUTTON (GPIO 4)     │  • PIN_LED (индикация)         │
├─────────────────────────────────────────────────────────────┤
│  Режимы работы:                                             │
│  • MODE_AUTO: Serial → TX FSM                               │
│  • MODE_MANUAL: Button → логика → TX FSM                    │
│  • MODE_RAW: Button → TX (напрямую)                         │
├─────────────────────────────────────────────────────────────┤
│  Параллельные процессы:                                     │
│  • TX FSM (передатчик)                                      │
│  • RX FSM (приёмник с прерываниями)                         │
│  • Обработка ввода (режимо-зависимая)                       │
└─────────────────────────────────────────────────────────────┘
```

### Аппаратная конфигурация

| Компонент | Пин | Назначение |
|-----------|-----|------------|
| PIN_RX | 2 | Вход с прерыванием (INT0), приём сигнала |
| PIN_TX | 3 | Выход передачи сигнала |
| PIN_BUTTON | 4 | Кнопка ручного ввода (INPUT_PULLUP) |
| PIN_DATA | 9 | 74HC595 - линия данных (DS) |
| PIN_LATCH | 10 | 74HC595 - защёлка (ST_CP) |
| PIN_CLOCK | 11 | 74HC595 - тактирование (SH_CP) |
| PIN_LED | 13 | Индикация передачи |

---

## Временные диаграммы

### 1. Базовые временные единицы

```
Параметр           | Длительность | Обозначение
-------------------|--------------|-------------
TIME_UNIT (1t)     | 100 мс       | Базовая единица
DOT_TIME           | 1t (100 мс)  | Точка "."
DASH_TIME          | 3t (300 мс)  | Тире "-"
SYMBOL_GAP         | 1t (100 мс)  | Пауза между точками/тире
LETTER_GAP         | 3t (300 мс)  | Пауза между буквами
WORD_GAP           | 7t (700 мс)  | Пауза между словами
```

### 2. Диаграмма передачи точки

```
PIN_TX:     ████░░░░
            HIGH LOW
Время:      |100|100|
            |ms |ms |
            └─┬─┘ └─┬─┘
           DOT  SYMBOL_GAP
```

### 3. Диаграмма передачи тире

```
PIN_TX:     ████████████░░░░
            HIGH        LOW
Время:      |   300ms   |100|
            └─────┬─────┘ └─┬─┘
                DASH    SYMBOL_GAP
```

### 4. Диаграмма передачи буквы "S" (...)

```
Символ:     .           .           .
PIN_TX:     ████░░░░    ████░░░░    ████░░░░        ░░░░░░░░░░░░
            HIGH LOW    HIGH LOW    HIGH LOW        LOW (пауза)
Время:      |100|100|   |100|100|   |100|100|       |   300ms   |
            └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘     └─────┬─────┘
           DOT  GAP  DOT  GAP  DOT  GAP          LETTER_GAP
```

### 5. Диаграмма передачи слова "SOS"

```
Символ:  S (...)              O (---)              S (...)
         
PIN_TX:  ████░████░████░░░░   ████████░████████░████████░░░░   ████░████░████░░░░   ░░░░░░░░░░░░░░░░░░░░░
         |<----S---->|300ms|   |<--------O-------->|300ms|       |<----S---->|300ms|   |     700ms      |
         
Время:              LETTER_GAP               LETTER_GAP                  LETTER_GAP      WORD_GAP (опц.)
```

### 6. Полная временная диаграмма передачи с протоколом

```
Фрейм:   [START]      [DATA: "A" = .-]       [END]
         
PIN_TX:  -.-.-        .-                     ...-.-
         (марк.)      (полезн.данные)        (марк.)
         
Время:   |------|300ms|------|300ms|-----------|
                ↑LETTER_GAP   ↑LETTER_GAP

Логика:  TX_SEND_START → TX_SEND_PAYLOAD → TX_SEND_END → TX_IDLE
```

### 7. Диаграмма приёма (RX)

```
PIN_RX:  ████████████░░░░░░░░    (входящий сигнал)
         ↑           ↑
         Прер.       Прер.
         RISING      FALLING
         
ISR:     rxPulseStart = t1      rxPulseWidth = t2 - t1
                                rxPulseReady = TRUE

RX FSM:                          Анализ ширины:
                                 100±50 мс → "."
                                 250+мс    → "-"
                                 
         Накопление: rxBufferSeq += "."
         
         После паузы >250мс → decodeMorseChar(rxBufferSeq)
```

---

## Конечные автоматы

### 1. TX FSM (Передатчик)

```
┌─────────────────────────────────────────────────────────────────┐
│                        TX_IDLE (начало)                          │
│  Ожидание данных в txBuffer или ручного ввода                   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   peekTxBuffer() != 0
      [state_change]   → TX_SEND_START
      [action]   Подготовка к отправке
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                     TX_SEND_START                                │
│  Отправка маркера начала протокола "-.-.-"                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   Всегда (безусловный переход)
      [state_change]   → TX_SIGNAL_HIGH
      [action]   currentMorseSeq = PROTOCOL_START
                 txSeqIndex = 0
                 txReturnState = TX_SEND_PAYLOAD
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                     TX_SIGNAL_HIGH                               │
│  Подача HIGH на PIN_TX (начало точки/тире)                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   txSeqIndex >= currentMorseSeq.length()
      [state_change]   → TX_NEXT_CHAR_WAIT
      [action]   Символ закончен
                        │
      [condition]   txSeqIndex < length
      [state_change]   → TX_WAIT_HIGH
      [action]   digitalWrite(PIN_TX, HIGH)
                 digitalWrite(PIN_LED, HIGH)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                     TX_WAIT_HIGH                                 │
│  Ожидание завершения длительности точки/тире                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   currentMillis - txLastTime >= duration
                    duration = (signal == '.') ? DOT_TIME : DASH_TIME
      [state_change]   → TX_WAIT_LOW
      [action]   digitalWrite(PIN_TX, LOW)
                 digitalWrite(PIN_LED, LOW)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                     TX_WAIT_LOW                                  │
│  Пауза между элементами символа (SYMBOL_GAP)                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   currentMillis - txLastTime >= SYMBOL_GAP
      [state_change]   → TX_SIGNAL_HIGH
      [action]   txSeqIndex++
                        │
                        ▼
                  (цикл для всех элементов)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                   TX_NEXT_CHAR_WAIT                              │
│  Пауза между буквами (LETTER_GAP)                               │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   currentMillis - txLastTime >= LETTER_GAP
      [state_change]   → txReturnState
      [action]   Переход к следующему состоянию
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                    TX_SEND_PAYLOAD                               │
│  Отправка полезных данных из буфера                             │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   peekTxBuffer() == 0 (буфер пуст)
      [state_change]   → TX_SEND_END
      [action]   Все данные отправлены
                        │
      [condition]   peekTxBuffer() == ' ' (пробел)
      [state_change]   → TX_NEXT_CHAR_WAIT
      [action]   popTxBuffer(), пауза между словами
                        │
      [condition]   Символ A-Z или 0-9
      [state_change]   → TX_SIGNAL_HIGH
      [action]   currentMorseSeq = charToMorse(c)
                 popTxBuffer()
                 txReturnState = TX_SEND_PAYLOAD
                        │
                        ▼
                  (цикл отправки)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                     TX_SEND_END                                  │
│  Отправка маркера конца протокола "...-.-"                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   Всегда
      [state_change]   → TX_SIGNAL_HIGH
      [action]   currentMorseSeq = PROTOCOL_END
                 txReturnState = TX_IDLE
                        │
                        ▼
                  (отправка маркера)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                        TX_IDLE                                   │
│  Возврат в состояние ожидания                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 2. RX FSM (Приёмник)

```
┌─────────────────────────────────────────────────────────────────┐
│                    Обработка прерывания rxISR()                  │
│  Вызывается на CHANGE (RISING/FALLING edge) PIN_RX              │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   digitalRead(PIN_RX) == HIGH (RISING)
      [state_change]   Начало импульса
      [action]   rxPulseStart = millis()
                 rxLastEdge = millis()
                        │
      [condition]   digitalRead(PIN_RX) == LOW (FALLING)
      [state_change]   Конец импульса
      [action]   rxPulseWidth = millis() - rxPulseStart
                 rxPulseReady = TRUE
                 rxLastEdge = millis()
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│               runReceiverFSM() - главный цикл                    │
│  Обработка готовых импульсов                                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   rxPulseReady == TRUE
      [state_change]   Анализ импульса
      [action]   width = rxPulseWidth
                 rxPulseReady = FALSE
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Классификация импульса                          │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   width ≈ DOT_TIME (100±150 мс)
      [state_change]   Точка распознана
      [action]   rxBufferSeq += "."
                        │
      [condition]   width ≥ DASH_TIME - TOLERANCE (≥250 мс)
      [state_change]   Тире распознано
      [action]   rxBufferSeq += "-"
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Обнаружение конца символа                       │
│  Проверка паузы после последнего импульса                       │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   PIN_RX == LOW && rxBufferSeq.length() > 0
                    && (now - rxLastEdge) > (LETTER_GAP - 50)
      [state_change]   Символ завершён
      [action]   decodeMorseChar(rxBufferSeq)
                 rxBufferSeq = ""
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                   decodeMorseChar(seq)                           │
│  Декодирование и вывод символа                                  │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   seq == PROTOCOL_START ("-.-.-")
      [state_change]   Начало фрейма
      [action]   rxFrameActive = TRUE
                 Serial.println("[RX] Frame START")
                        │
      [condition]   seq == PROTOCOL_END ("...-.-")
      [state_change]   Конец фрейма
      [action]   rxFrameActive = FALSE
                 Serial.println("[RX] Frame END")
                        │
      [condition]   seq совпадает с MORSE_LETTERS[i]
      [state_change]   Буква распознана
      [action]   decoded = 'A' + i
                 displayChar(decoded)
                 Serial.print(decoded)
                        │
      [condition]   seq совпадает с MORSE_NUMBERS[i]
      [state_change]   Цифра распознана
      [action]   decoded = '0' + i
                 displayChar(decoded)
                 Serial.print(decoded)
                        │
      [condition]   Не распознано
      [state_change]   Ошибка декодирования
      [action]   decoded = '?'
                        │
                        ▼
                  (возврат в ожидание)
```

### 3. FSM обработки ручного ввода (MODE_MANUAL)

```
┌─────────────────────────────────────────────────────────────────┐
│                   handleManualMode() - цикл                      │
│  Обработка нажатий кнопки с накоплением последовательности      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Чтение кнопки с Debounce                       │
│  readButtonDebounced() - фильтрация дребезга                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   isPressed && !buttonPressed
      [state_change]   Начало нажатия
      [action]   buttonPressed = TRUE
                 buttonPressStart = millis()
                 digitalWrite(PIN_LED, HIGH)
                        │
      [condition]   !isPressed && buttonPressed
      [state_change]   Конец нажатия
      [action]   buttonPressed = FALSE
                 duration = millis() - buttonPressStart
                 digitalWrite(PIN_LED, LOW)
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                 Классификация длительности                       │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   duration < 300 мс
      [state_change]   Точка введена
      [action]   manualMorseSeq += "."
                 lastButtonRelease = millis()
                        │
      [condition]   duration >= 300 мс
      [state_change]   Тире введено
      [action]   manualMorseSeq += "-"
                 lastButtonRelease = millis()
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│               Обнаружение конца символа                          │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   !isPressed && manualMorseSeq.length() > 0
                    && (now - lastButtonRelease) > LETTER_GAP
      [state_change]   Символ завершён
      [action]   sendManualMorse(manualMorseSeq)
                 manualMorseSeq = ""
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                    sendManualMorse(seq)                          │
│  Запуск TX FSM для отправки                                     │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   txState != TX_IDLE
      [state_change]   Передатчик занят
      [action]   return (отклонение запроса)
                        │
      [condition]   txState == TX_IDLE
      [state_change]   Запуск передачи
      [action]   currentMorseSeq = sequence
                 txSeqIndex = 0
                 txState = TX_SIGNAL_HIGH
                 txReturnState = TX_IDLE
```

### 4. FSM обработки RAW режима (MODE_RAW)

```
┌─────────────────────────────────────────────────────────────────┐
│                    handleRawMode() - цикл                        │
│  Прямое отображение состояния кнопки на PIN_TX                  │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Чтение кнопки с Debounce                       │
│  readButtonDebounced() - фильтрация дребезга                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      [condition]   isPressed == TRUE
      [state_change]   Кнопка нажата
      [action]   digitalWrite(PIN_TX, HIGH)
                 digitalWrite(PIN_LED, HIGH)
                        │
      [condition]   isPressed == FALSE
      [state_change]   Кнопка отпущена
      [action]   digitalWrite(PIN_TX, LOW)
                 digitalWrite(PIN_LED, LOW)
                        │
                        ▼
                  (непрерывный цикл)

Особенность: TX FSM НЕ ЗАПУСКАЕТСЯ в RAW режиме!
Управление PIN_TX происходит напрямую, без логики кодирования.
```

### 5. Диаграмма режимов работы

```
┌─────────────────────────────────────────────────────────────────┐
│                       MAIN LOOP                                  │
└───────────────────────┬─────────────────────────────────────────┘
                        │
      handleSerialInput() - обработка команд и данных
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Выбор режима (currentMode)                      │
└────┬────────────────────┬────────────────────┬───────────────────┘
     │                    │                    │
     ▼                    ▼                    ▼
┌─────────┐       ┌─────────────┐      ┌──────────┐
│MODE_AUTO│       │ MODE_MANUAL │      │ MODE_RAW │
│         │       │             │      │          │
│Serial→TX│       │Button→Logic │      │Button→TX │
│  (FSM)  │       │    →TX(FSM) │      │ (Direct) │
└────┬────┘       └──────┬──────┘      └─────┬────┘
     │                   │                   │
     ▼                   ▼                   ▼
     │            runTransmitterFSM()        │
     │            (если не RAW)              │
     └───────────────────┬───────────────────┘
                         │
                         ▼
                 runReceiverFSM()
                 (всегда активен)
```

---

## Режимы работы

### 1. MODE_AUTO (автоматический)

**Источник данных:** Serial (USB)

**Логика работы:**
- Пользователь вводит текст через Serial Monitor
- Символы A-Z, 0-9 и пробелы помещаются в кольцевой буфер `txBuffer`
- TX FSM автоматически извлекает символы и преобразует их в код Морзе
- Передача осуществляется с маркерами протокола (START/END)

**Временная диаграмма:**
```
Serial:  H E L L O [Enter]
         ↓ ↓ ↓ ↓ ↓
txBuffer: [H][E][L][L][O]
         ↓
TX FSM:  [START] .... . .-.. .-.. --- [END]
         ↓
PIN_TX:  (физическая передача)
```

**Особенности:**
- Буферизация до 64 символов
- Защита от переполнения буфера
- Автоматическое кодирование в азбуку Морзе
- Корректная обработка пробелов (WORD_GAP)

### 2. MODE_MANUAL (ручной с логикой)

**Источник данных:** Кнопка (PIN_BUTTON)

**Логика работы:**
- Пользователь нажимает кнопку для ввода точек и тире
- Короткое нажатие (<300 мс) → точка "."
- Длинное нажатие (≥300 мс) → тире "-"
- Пауза >300 мс (LETTER_GAP) → завершение символа и отправка
- Накопленная последовательность передаётся через TX FSM

**Временная диаграмма:**
```
Кнопка:  ████░░░ ████████████░░░ ████░░░ ░░░░░░░░░░░░
         |100| |    300    | |100|   |   >300мс   |
         └┬─┘  └──────┬─────┘  └┬─┘    └─────┬─────┘
          .           -          .         Пауза

manualMorseSeq: ".-." → sendManualMorse(".-.")
                        ↓
                      TX FSM → PIN_TX: .-.-
```

**Алгоритм Debounce:**
```cpp
// Фильтрация дребезга контактов (50 мс)
if (reading != lastButtonState) {
    lastDebounceTime = millis();
}
if ((millis() - lastDebounceTime) > DEBOUNCE_DELAY) {
    if (reading != buttonState) {
        buttonState = reading; // Стабильное состояние
    }
}
```

**Особенности:**
- Визуальная обратная связь через PIN_LED во время ввода
- Накопление последовательности в буфере `manualMorseSeq`
- Отправка только завершённых символов
- Защита от дребезга контактов (50 мс)

### 3. MODE_RAW (прямое управление)

**Источник данных:** Кнопка (PIN_BUTTON)

**Логика работы:**
- Кнопка напрямую управляет PIN_TX
- Нажата → HIGH, отпущена → LOW
- Нет кодирования, нет FSM передатчика
- "Прозрачный мост" для низкоуровневого тестирования

**Временная диаграмма:**
```
Кнопка:  ████████████░░░░░░░░████░░░░
         |           |       |  |
PIN_TX:  ████████████░░░░░░░░████░░░░  (точная копия)
         
         Соответствие 1:1 без обработки
```

**Особенности:**
- TX FSM **не запускается** в этом режиме (см. `if (currentMode != MODE_RAW)`)
- Используется для:
  - Тестирования физического канала связи
  - Отладки RX без протокольных маркеров
  - Ручной передачи произвольных сигналов
- RX FSM продолжает работать для приёма

### Переключение режимов

**Команды через Serial:**
```
!A → MODE_AUTO     (Serial → TX)
!M → MODE_MANUAL   (Button → Sequence → TX)
!R → MODE_RAW      (Button → TX Direct)
```

**Реализация:**
```cpp
if (c == '!') {
    char mode = toupper(Serial.read());
    switch(mode) {
        case 'A': currentMode = MODE_AUTO; break;
        case 'M': currentMode = MODE_MANUAL; break;
        case 'R': currentMode = MODE_RAW; break;
    }
}
```

---

## Проектные решения

### 1. Архитектурные решения

#### 1.1 Конечные автоматы (FSM)

**Обоснование:**
- Чёткое разделение состояний (TX_IDLE, TX_SIGNAL_HIGH и т.д.)
- Предсказуемое поведение при любых входных данных
- Упрощённая отладка (каждое состояние можно логировать)
- Исключение гонки условий (race conditions)

**Альтернативы:**
- ❌ Блокирующие `delay()` - замораживают весь код, невозможен параллельный приём
- ❌ Простые таймеры без состояний - сложная логика, трудно расширять

#### 1.2 Прерывания для RX

**Обоснование:**
- Точное измерение длительности импульсов (аппаратная поддержка)
- Не пропускаются короткие импульсы (точки 100 мс)
- Минимальная нагрузка на процессор

**Реализация:**
```cpp
attachInterrupt(digitalPinToInterrupt(PIN_RX), rxISR, CHANGE);

void rxISR() {
    int state = digitalRead(PIN_RX);
    if (state == LOW) { 
        rxPulseWidth = millis() - rxPulseStart; // Захват ширины
        rxPulseReady = true; 
    } else {
        rxP