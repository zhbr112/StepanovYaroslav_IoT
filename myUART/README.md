# Разбор кода программной реализации UART

## 1. Структура проекта и основные компоненты

### 1.1. Заголовочные файлы и макросы

```cpp
#include <util/atomic.h>

#define TX_PIN PD3 // Пин D3 для передачи (TX)
#define RX_PIN PD2 // Пин D2 (INT0) для приёма (RX)
#define UART_BUFFER_SIZE 64
```

- **`util/atomic.h`**: Обеспечивает атомарные операции для безопасного доступа к переменным, разделяемым между основным кодом и обработчиками прерываний (ISR).
- **Пины**: Фиксированные номера пинов для TX и RX.
- **Размер буфера**: 64 байта для буферов приёма и передачи.

### 1.2. Кольцевые буферы

```cpp
volatile char tx_buffer[UART_BUFFER_SIZE];
volatile uint8_t tx_head = 0, tx_tail = 0;

volatile char rx_buffer[UART_BUFFER_SIZE];
volatile uint8_t rx_head = 0, rx_tail = 0;
```

**Особенности реализации:**

- `volatile`: Гарантирует, что компилятор не будет кэшировать в регистрах переменные, которые могут быть изменены в прерываниях, обеспечивая чтение актуальных значений из памяти.
- `head`: Индекс для записи нового элемента в буфер.
- `tail`: Индекс для чтения самого старого элемента из буфера.
- **Кольцевая структура**: Индексы циклически изменяются в пределах `0` до `UART_BUFFER_SIZE - 1` с помощью операции взятия остатка от деления (`%`).

## 2. Система состояний UART

### 2.1. Общие переменные состояния

```cpp
volatile uint16_t ticks_per_bit = 0;
```

- Рассчитывается один раз в `uart_set_baudrate()` на основе `F_CPU` и скорости передачи.
- Хранит количество тиков таймера, соответствующее длительности одного бита. Это основа всей синхронизации.

### 2.2. Состояние передатчика (TX)

```cpp
enum { TX_IDLE, TX_START_BIT, TX_DATA_BITS, TX_STOP_BIT } volatile tx_state = TX_IDLE;
volatile uint8_t tx_byte_to_send;
volatile uint8_t tx_bit_count;
```

**Конечный автомат TX:**

- `tx_state`: Переменная, хранящая текущее состояние передатчика. Определяет, какой этап передачи байта выполняется в данный момент.
- `tx_byte_to_send`: Копия байта, извлечённого из буфера для передачи.
- `tx_bit_count`: Счётчик отправленных битов данных (от 0 до 7).

### 2.3. Состояние приёмника (RX)

```cpp
volatile uint8_t rx_byte;
volatile uint8_t rx_bit_count;
```

**Конечный автомат RX:**

- `rx_byte`: Байт, который постепенно собирается из принятых бит.
- `rx_bit_count`: Счётчик принятых битов данных (от 0 до 7).

## 3. Детальный разбор функций API

### 3.1. Настройка скорости передачи

```cpp
void uart_set_baudrate(int rate) {
    ticks_per_bit = (F_CPU / 8) / rate;
    TCCR1A = 0;
    TCCR1B = (1 << CS11); // Предделитель 8
}
```

**Расчёт временных параметров:**

- **Формула**: `ticks_per_bit = F_CPU / (предделитель × baudrate)`.
- **Пример для 16 МГц, 9600 бод**: `16000000 / (8 × 9600) = 208.33`. Целая часть (208) используется для расчетов.
- Timer1 настраивается в нормальном режиме с предделителем 8, что обеспечивает хороший баланс между разрешением и диапазоном для стандартных скоростей UART.

### 3.2. Функция передачи байта

```cpp
void uart_send(char b) {
    uint8_t next_head = (tx_head + 1) % UART_BUFFER_SIZE;
    if (next_head == tx_tail) return; // Буфер полон

    tx_buffer[tx_head] = b;
    tx_head = next_head;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        if (tx_state == TX_IDLE) {
            tx_state = TX_START_BIT;
            OCR1A = TCNT1 + 10;
            TIMSK1 |= (1 << OCIE1A);
        }
    }
}
```

**Ключевые моменты:**

1.  **Проверка переполнения**: Сравнивается следующий возможный `head` с текущим `tail`. Если они равны, буфер полон.
2.  **Атомарная операция**: Критическая секция, где проверяется состояние `tx_state` и запускается таймер, защищена от прерываний. Это предотвращает состояние гонки.
3.  **Запуск передачи**: Если передатчик был в состоянии покоя (`TX_IDLE`), он переводится в состояние `TX_START_BIT`, и активируется прерывание по совпадению для канала A таймера.

### 3.3. Функции приёма данных

```cpp
uint8_t uart_available() {
    uint8_t count;
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        count = (rx_head - rx_tail + UART_BUFFER_SIZE) % UART_BUFFER_SIZE;
    }
    return count;
}
```

**Особенности:**

- Атомарное вычисление количества доступных для чтения байт в буфере.
- Формула `(head - tail + size) % size` корректно работает даже при переполнении индексов.

```cpp
char uart_read() {
    if (rx_head == rx_tail) return -1;
    char b = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) % UART_BUFFER_SIZE;
    return b;
}
```

**Безопасное извлечение данных:**

- Сначала проверяется, пуст ли буфер.
- Чтение байта и обновление индекса `tail` не требует атомарности, так как `tail` изменяется только в этой функции, а не в ISR.

## 4. Обработчики прерываний - ядро системы

### 4.1. Обработчик внешнего прерывания (старт-бит)

```cpp
ISR(INT0_vect) {
    EIMSK &= ~(1 << INT0);

    rx_byte = 0;
    rx_bit_count = 0;

    OCR1B = TCNT1 + ticks_per_bit + (ticks_per_bit / 2);
    TIFR1 |= (1 << OCF1B);
    TIMSK1 |= (1 << OCIE1B);
}
```

**Алгоритм обнаружения старта:**

1.  **Блокировка**: Прерывание `INT0` немедленно отключается, чтобы избежать ложных срабатываний (дребезг или биты данных) во время приёма байта.
2.  **Инициализация**: Сбрасывается состояние конечного автомата приёмника.
3.  **Синхронизация**: Регистр сравнения `OCR1B` настраивается так, чтобы первое прерывание таймера произошло ровно в середине первого бита данных (через 1.5 длительности бита от момента обнаружения спадающего фронта).
4.  **Активация**: Включается прерывание по совпадению для канала B таймера, которое будет считывать последующие биты.

### 4.2. Обработчик передачи (TIMER1_COMPA_vect)

```cpp
ISR(TIMER1_COMPA_vect) {
    OCR1A += ticks_per_bit;

    switch (tx_state) {
        case TX_START_BIT:
            // ... извлекаем байт, отправляем старт-бит (LOW), переходим в TX_DATA_BITS
            break;
        case TX_DATA_BITS:
            // ... отправляем 8 бит данных (LSB first), переходим в TX_STOP_BIT
            break;
        case TX_STOP_BIT:
            // ... отправляем стоп-бит (HIGH), решаем, начать ли новый байт или перейти в TX_IDLE
            break;
    }
}
```

**Конечный автомат передачи:**

- **`TX_START_BIT`**: Проверяет, есть ли данные в буфере. Если да, извлекает байт, устанавливает пин в LOW (старт-бит) и переходит в состояние `TX_DATA_BITS`.
- **`TX_DATA_BITS`**: Последовательно отправляет 8 бит данных, от LSB к MSB. После 8-го бита переходит в состояние `TX_STOP_BIT`.
- **`TX_STOP_BIT`**: Устанавливает пин в HIGH (стоп-бит). **Этот бит длится полный интервал**. После этого проверяется буфер: если есть еще данные, автомат переходит в `TX_START_BIT`; если нет — в `TX_IDLE`, и прерывание отключается.

### 4.3. Обработчик приёма (TIMER1_COMPB_vect)

```cpp
ISR(TIMER1_COMPB_vect) {
    OCR1B += ticks_per_bit;

    if (rx_bit_count < 8) {
        // Приём 8-ми битов данных
        if (PIND & (1 << RX_PIN)) {
            rx_byte |= (1 << rx_bit_count);
        }
        rx_bit_count++;
    } else {
        // Проверка стоп-бита
        if (PIND & (1 << RX_PIN)) {
            // ... сохраняем байт в буфер, если стоп-бит корректен
        }

        // Завершение приёма
        TIMSK1 &= ~(1 << OCIE1B); // Отключаем таймер RX
        EIMSK |= (1 << INT0);    // Снова разрешаем поиск старт-бита
    }
}
```

**Алгоритм приёма:**

- **Биты 0-7**: В каждом прерывании считывается состояние пина RX. Если оно HIGH, устанавливается соответствующий бит в `rx_byte` (начиная с LSB).
- **Бит 8**: Последнее прерывание для этого байта происходит в момент времени, где должен быть стоп-бит. Проверяется, что пин находится в состоянии HIGH. Если да, собранный байт помещается в RX-буфер.
- **Завершение**: Вне зависимости от корректности стоп-бита, прерывание таймера для приёма отключается, а внешнее прерывание `INT0` снова включается для ожидания следующего байта.

## 5. Инициализация и демонстрационная логика

### 5.1. Функция setup()

```cpp
void setup() {
    DDRD |= (1 << TX_PIN);  // TX как выход
    PORTD |= (1 << TX_PIN); // Состояние покоя (idle) - HIGH

    DDRD &= ~(1 << RX_PIN); // RX как вход
    PORTD |= (1 << RX_PIN); // Включение внутреннего подтягивающего резистора

    uart_set_baudrate(9600);

    EICRA |= (1 << ISC01); // Прерывание INT0 по спадающему фронту
    EIMSK |= (1 << INT0);  // Разрешение прерывания INT0

    sei();                 // Глобальное разрешение всех прерываний

    uart_send_string("Software UART v5 Stable - OK\r\n");
}
```

### 5.2. Демонстрационный цикл (эхо-сервер)

```cpp
void loop() {
  if (uart_available()) {
    char c = uart_read();
    uart_send(c);
  }
}
```

Основной цикл программы предельно прост: он постоянно проверяет, не появились ли в RX-буфере новые данные. Если данные есть, он считывает один байт и немедленно отправляет его обратно через TX, демонстрируя работу эхо-сервера.

## 6. Выполненные требования:

1.  **Асинхронная работа**: TX и RX процессы полностью управляются прерываниями и работают в фоновом режиме, не блокируя `loop()`.
2.  **Кольцевые буферы**: Реализованы для TX и RX с корректной обработкой (потеря данных при переполнении).
3.  **Таймерная синхронизация**: Timer1 с двумя независимыми каналами сравнения обеспечивает точные временные интервалы для одновременной дуплексной работы.
4.  **Внешнее прерывание для старта**: INT0 на спадающем фронте используется для надёжного обнаружения старт-бита.
5.  **Прямая работа с регистрами**: Настройка пинов и прерываний выполняется напрямую через регистры `DDRx`, `PORTx`, `EICRA`, `EIMSK` и т.д.
6.  **Эффективные ISR**: Обработчики прерываний содержат только минимально необходимый код для управления конечными автоматами.
7.  **Volatile переменные**: Все переменные, разделяемые между основным кодом и ISR, корректно объявлены как `volatile`.
8.  **Независимые RX/TX**: Решение не использует допущение о невозможности одновременной работы приёма и передачи.
