### **Детальный разбор кода**

#### **1. Глобальные переменные и структуры**

В самом начале мы готовим все данные, которые понадобятся программе.

```cpp
#define NUM_LEDS 5

struct LedState {
  volatile uint16_t counter; // Личный счётчик тиков
  const uint16_t period;     // Через сколько тиков переключаться
};

LedState leds[NUM_LEDS] = { /* ... */ };
```

*   **`struct LedState`**: Группируем информацию для светодиода(период и счётчик) в одну структуру.
*   **`volatile uint16_t counter`**: Это счётчик для каждого светодиода.
*   **`const uint16_t period`**: Константа до которой должен досчитать `counter` свветодиода что бы перключиться.
*   **`LedState leds[NUM_LEDS]`**: Массив из пяти светодиодов, где у каждого есть свой счётчик и заданный период.

#### **2. Настройка в `setup()`**

В этой функции мы один раз настраиваем всё необходимое для работы.

```cpp
cli(); // и sei();
```
Команда `cli()` временно "заглушает" все прерывания. Мы делаем это, чтобы спокойно настроить наш таймер, не боясь, что он сработает в середине процесса. В конце мы снова всё включаем командой `sei()`.

```cpp
DDRD |= (1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6);
```
**Готовим пины к работе.** Мы сообщаем микроконтроллеру, что пины со 2-го по 6-й будут работать "на выход" (т.е. управлять светодиодами). Запись `(1<<PD2)`.

```cpp
// ... Настройка Timer1 ...
TCCR1B |= (1 << WGM12);  // Режим CTC
TCCR1B |= (1 << CS12);   // Предделитель 256
OCR1A = 624;
```
**Настраиваем наш тайммер.** Это самая важная часть.
*   Мы выбираем режим **CTC**: таймер будет считать не до своего максимума, а до числа, которое мы запишем в `OCR1A`, после чего сбросится и вызовет прерывание.
*   Мы ставим **предделитель 256**: тактовая частота процессора (16 МГц) слишком высока, поэтому мы её замедляем в 256 раз.
*   **Вычисляем `OCR1A`**: Чтобы тайммер звонил ровно 100 раз в секунду (каждые 10 мс), мы делаем простой расчёт:
    *   Частота таймера: `16 000 000 Гц / 256 = 62 500 Гц`
    *   Нужное значение = `(Частота_таймера / 100 Гц) - 1`
    *   `62 500 / 100 - 1 = 625 - 1 = 624`

```cpp
TIMSK1 |= (1 << OCIE1A);
```
Этой командой мы разрешаем прерывание именно от нашего таймера. Теперь, как только счётчик достигнет `624`, программа запустит сигнал для прерывания.

#### **3. Обработчик прерывания `ISR()`**

Эта функция — сердце программы. Она выполняется автоматически 100 раз в секунду, каждый раз, когда таймер "звонит".

```cpp
ISR(TIMER1_COMPA_vect) {
  for (uint8_t i = 0; i < NUM_LEDS; i++) {
    leds[i].counter++;

    if (leds[i].counter >= leds[i].period) {
      leds[i].counter = 0;
      PORTD ^= (1 << (i + 2));
    }
  }
}
```
*   `for (uint8_t i = 0; i < NUM_LEDS; i++)`: Пробегаемся по всему нашему массиву светодиодов.
*   `leds[i].counter++;`: Увеличиваем личный счётчик для каждого светодиода на единицу.
*   `if (leds[i].counter >= leds[i].period)`: Проверяем, не пора ли переключаться.
*   `leds[i].counter = 0;`: Если пора, сбрасываем счётчик, чтобы начать отсчёт заново.
*   `PORTD ^= (1 << (i + 2));`:
    *   `(i + 2)`: Наш цикл идёт от `i = 0` до `4`, а пины у нас `2` до `6`. Это простое смещение превращает индекс `0` в номер пина `2`, `1` в `3` и так далее.
    *   `(1 << ...)`: Создаёт битовую "маску", где единичка стоит ровно на месте нужного нам пина. Например, для `i=0` (пин 2) маска будет `0b00000100`.
    *   `^=`: Оператор "Исключающее ИЛИ" (XOR) работает как переключатель. Он инвертирует состояние только одного бита (нашего пина), не трогая остальные. Если светодиод горел — он погаснет, если не горел — зажжётся.

### **Результаты и тестирование**

После загрузки этого кода светодиоды начнут мигать. Давайте посчитаем задежку между перключениями состояния:
*   **Светодиод на пине 2 (период 50):** `50 * 10 мс` = **500 мс**.
*   **Светодиод на пине 3 (период 100):** `100 * 10 мс` = **1000 мс**.
*   **Светодиод на пине 4 (период 150):** `150 * 10 мс` = **1500 мс**.
*   **Светодиод на пине 5 (период 200):** `200 * 10 мс` = **2000 мс**.
*   **Светодиод на пине 6 (период 250):** `250 * 10 мс` = **2500 мс**.