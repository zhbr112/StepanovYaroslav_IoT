// Количество управляемых светодиодов
#define NUM_LEDS 5

// Структура для хранения состояния каждого светодиода
struct LedState {
  volatile uint16_t counter; // Текущий счетчик тиков
  const uint16_t period;     // Период переключения в тиках
};

// Массив для хранения состояний всех светодиодов и их периодов
LedState leds[NUM_LEDS] = {
  {0, 50},
  {0, 100},
  {0, 150},
  {0, 200},
  {0, 250}
};

void setup() {
  // 1. Настройка пинов порта D (PD2-PD6) как выходов
  // Устанавливаем биты 2, 3, 4, 5, 6 регистра DDRD в '1'
  DDRD |= (1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD5)|(1<<PD6);

  // 2. Настройка Timer1 для генерации прерывания
  cli(); // Отключить прерывания на время настройки

  // Сброс регистров управления таймером
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;

  TCCR1B |= (1 << WGM12); // Режим CTC
  TCCR1B |= (1 << CS12);  // Предделитель 256
  
  // Установка значения для сравнения (OCR1A) для частоты 100 Гц
  // OCR1A = (16,000,000 / (256 * 100)) - 1 = 624
  OCR1A = 624;

  // Разрешение прерывания по совпадению с OCR1A
  TIMSK1 |= (1 << OCIE1A);

  sei(); // Включить прерывания
}

// Обработчик прерывания по совпадению с OCR1A для Timer1
ISR(TIMER1_COMPA_vect) {
  for (uint8_t i = 0; i < NUM_LEDS; i++) {
    leds[i].counter++;
    
    if (leds[i].counter >= leds[i].period) {
      leds[i].counter = 0;
      // Инвертируем состояние пина (i + 2) порта D.
      PORTD ^= (1 << (i + 2));
    }
  }
}

void loop() {
}